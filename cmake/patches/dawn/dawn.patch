diff --git a/src/emdawnwebgpu/CMakeLists.txt b/src/emdawnwebgpu/CMakeLists.txt
index 6e8ae37593..633af91eef 100644
--- a/src/emdawnwebgpu/CMakeLists.txt
+++ b/src/emdawnwebgpu/CMakeLists.txt
@@ -77,9 +77,17 @@ if (${DAWN_ENABLE_EMSCRIPTEN})
                 "${arg_UNPARSED_ARGUMENTS}")
         endif()
 
+        # since Emscripten 4.0.3, file gen_struct_info.py is moved to outside of directory maint.
+        if (EXISTS "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/gen_struct_info.py")
+            set(EM_GEN_STRUCT_INFO_SCRIPT "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/gen_struct_info.py")
+        elseif (EXISTS "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/maint/gen_struct_info.py")
+            set(EM_GEN_STRUCT_INFO_SCRIPT "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/maint/gen_struct_info.py")
+        else()
+            message(FATAL_ERROR "Dawn: Failed to locate file gen_struct_info.py from Emscripten.")
+        endif()
         set(ARGS
             ${Python3_EXECUTABLE}
-            "${DAWN_EMSCRIPTEN_TOOLCHAIN}/tools/maint/gen_struct_info.py"
+            "${EM_GEN_STRUCT_INFO_SCRIPT}"
             -q
             "${EM_BUILD_GEN_DIR}/struct_info_webgpu.json"
             "-I=${EM_BUILD_GEN_DIR}/include"
diff --git a/src/emdawnwebgpu/README.md b/src/emdawnwebgpu/README.md
index efd6491cd6..8ebc5d28b6 100644
--- a/src/emdawnwebgpu/README.md
+++ b/src/emdawnwebgpu/README.md
@@ -56,7 +56,7 @@ Set up the build directory using emcmake
 mkdir out/cmake-wasm
 cd out/cmake-wasm
 
-# Make sure the path is to the source checkout of Emscripten, not emsdk's release.
+# If using Emscripten v4.0.2 or lower, make sure the path is to the source checkout of Emscripten, not emsdk's release.
 emcmake cmake -GNinja -DDAWN_EMSCRIPTEN_TOOLCHAIN="path/to/emscripten" ../..
 
 ninja
diff --git a/third_party/emdawnwebgpu/library_webgpu.js b/third_party/emdawnwebgpu/library_webgpu.js
index 5862ce4045..5c59dbd223 100644
--- a/third_party/emdawnwebgpu/library_webgpu.js
+++ b/third_party/emdawnwebgpu/library_webgpu.js
@@ -584,6 +584,10 @@ var LibraryWebGPU = {
 
   emwgpuDelete__sig: 'vp',
   emwgpuDelete: (ptr) => {
+    // const b = WebGPU.Internals.jsObjects[ptr];
+    // if (b instanceof GPUBuffer) {
+    //   console.log("deleting buffer", ptr);
+    // }
     delete WebGPU.Internals.jsObjects[ptr];
   },
 
@@ -811,6 +815,61 @@ var LibraryWebGPU = {
     {{{ runtimeKeepalivePush() }}}
     WebGPU.Internals.futureInsert(futureId, adapter.requestDevice(desc).then((device) => {
       {{{ runtimeKeepalivePop() }}}
+
+      // a set that caches all active buffers
+      const buffers = WebGPU.Internals.buffers ??= new Set();
+      // key is buffer usage, value is total size of buffers with that usage
+      const buffersTotalSize = WebGPU.Internals.buffersTotalSize ??= new Map();
+
+      WebGPU.Internals.buffersCreated ??= 0;
+      WebGPU.Internals.buffersDestroyed ??= 0;
+      WebGPU.Internals.buffersUploads ??= 0;
+      WebGPU.Internals.buffersExternalUploads ??= 0;
+      WebGPU.Internals.buffersDownloads ??= 0;
+      WebGPU.Internals.buffersExternalDownloads ??= 0;
+
+      if ('WEBGPU_STAT' in globalThis) {
+        // create a proxy so that we can monitor buffer usages
+        device = new Proxy(device, {
+          // when call device.createBuffer(), the returned buffer should be added into buffers
+          get: (target, prop, _receiver) => {
+            if (prop === 'createBuffer') {
+              return (desc) => {
+                const buffer = target.createBuffer(desc);
+                const originalDestroy = buffer.destroy.bind(buffer);
+                buffer.destroy = () => {
+                  const previousTotal = buffersTotalSize.get(buffer.usage);
+                  buffersTotalSize.set(buffer.usage, previousTotal - buffer.size);
+                  buffers.delete(buffer);
+                  WebGPU.Internals.buffersDestroyed++;
+                  originalDestroy();
+                };
+
+                if (buffer.usage === (GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC)) {
+                  WebGPU.Internals.buffersUploads++;
+                }
+                if (buffer.usage === (GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ)) {
+                  WebGPU.Internals.buffersDownloads++;
+                }
+
+                buffers.add(buffer);
+                const previousTotal = buffersTotalSize.get(buffer.usage) ?? 0;
+                buffersTotalSize.set(buffer.usage, previousTotal + buffer.size);
+                WebGPU.Internals.buffersCreated++;
+                return buffer;
+              };
+            }
+            const propertyValue = Reflect.get(target, prop);
+            if (typeof propertyValue === 'function') {
+              return propertyValue.bind(target);
+            } else {
+              return propertyValue;
+            }
+          },
+          set: (target, prop, value, _receiver) => Reflect.set(target, prop, value),
+        });
+      }
+
       WebGPU.Internals.jsObjectInsert(queuePtr, device.queue);
       WebGPU.Internals.jsObjectInsert(devicePtr, device);
 
diff --git a/third_party/emdawnwebgpu/webgpu.cpp b/third_party/emdawnwebgpu/webgpu.cpp
index ca52b1237b..a30ca583c3 100644
--- a/third_party/emdawnwebgpu/webgpu.cpp
+++ b/third_party/emdawnwebgpu/webgpu.cpp
@@ -131,7 +131,6 @@ class RefCounted : NonMovable {
   bool Release() {
     if (mRefCount.fetch_sub(1u, std::memory_order_release) == 1u) {
       std::atomic_thread_fence(std::memory_order_acquire);
-      emwgpuDelete(this);
       return true;
     }
     return false;
@@ -234,6 +233,7 @@ class Ref {
   static void Release(T value) {
     if (value != nullptr && value->RefCounted::Release()) {
       delete value;
+      emwgpuDelete(value);
     }
   }
 
@@ -642,6 +642,7 @@ struct WGPUBufferImpl final : public EventSource,
                               public RefCountedWithExternalCount {
  public:
   WGPUBufferImpl(const EventSource* source, bool mappedAtCreation);
+  ~WGPUBufferImpl();
 
   void Destroy();
   const void* GetConstMappedRange(size_t offset, size_t size);
@@ -1164,11 +1165,17 @@ WGPUAdapter emwgpuCreateAdapter(const EventSource* source) {
 
 WGPUBuffer emwgpuCreateBuffer(const EventSource* source,
                               bool mappedAtCreation = false) {
-  return new WGPUBufferImpl(source, mappedAtCreation);
+  auto x = new WGPUBufferImpl(source, mappedAtCreation);
+  // printf(" #C++: emwgpuCreateBuffer %p\n", x);
+  return x;
 }
 
 WGPUDevice emwgpuCreateDevice(const EventSource* source, WGPUQueue queue) {
-  return new WGPUDeviceImpl(source, queue);
+  // This function is only called from JS via `importJsDevice()`, which
+  // needs to increment the external ref count to fix the behavior.
+  WGPUDeviceImpl* device = new WGPUDeviceImpl(source, queue);
+  device->AddExternalRef();
+  return device;
 }
 
 WGPUQueue emwgpuCreateQueue(const EventSource* source) {
@@ -1284,6 +1291,10 @@ WGPUBufferImpl::WGPUBufferImpl(const EventSource* source, bool mappedAtCreation)
   }
 }
 
+WGPUBufferImpl::~WGPUBufferImpl() {
+  Destroy();
+}
+
 void WGPUBufferImpl::Destroy() {
   emwgpuBufferDestroy(this);
   AbortPendingMap("Buffer was destroyed before mapping was resolved.");
@@ -1504,6 +1515,7 @@ WGPUFuture WGPUShaderModuleImpl::GetCompilationInfo(
   void wgpu##Name##Release(WGPU##Name o) {       \
     if (o->Release()) {                          \
       delete o;                                  \
+      emwgpuDelete(o);                           \
     }                                            \
   }
 WGPU_OBJECTS(DEFINE_WGPU_DEFAULT_ADDREF_RELEASE)
@@ -1587,6 +1599,7 @@ WGPUFuture wgpuAdapterRequestDevice(
 // ----------------------------------------------------------------------------
 
 void wgpuBufferDestroy(WGPUBuffer buffer) {
+  // printf(" #C++: wgpuBufferDestroy %p\n", buffer);
   buffer->Destroy();
 }
 
@@ -1639,6 +1652,7 @@ void wgpuBufferUnmap(WGPUBuffer buffer) {
 WGPUBuffer wgpuDeviceCreateBuffer(WGPUDevice device,
                                   const WGPUBufferDescriptor* descriptor) {
   WGPUBuffer buffer = new WGPUBufferImpl(device, descriptor->mappedAtCreation);
+  // printf(" #C++: wgpuDeviceCreateBuffer %p\n", buffer);
   emwgpuDeviceCreateBuffer(device, descriptor, buffer);
   return buffer;
 }
